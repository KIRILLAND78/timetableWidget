# Эволюция архитектуры виджета расписания: от монолита к мультиплатформенному решению

## Введение

TimetableWidget — это кроссплатформенное приложение для отображения расписания занятий студентов Чувашского государственного университета имени И.Н. Ульянова. Проект начинался как простое Windows-приложение, которое позволяло студентам видеть своё расписание прямо на рабочем столе, не открывая браузер и не заходя на сайт университета. Однако по мере развития проекта стало очевидно, что монолитная архитектура ограничивает возможности расширения на другие платформы и затрудняет поддержку различных графических оболочек Linux.

В данной статье рассматривается путь трансформации проекта от монолитного приложения Windows Forms к современной архитектуре с централизованным бэкендом и множеством специализированных адаптеров для различных десктоп-окружений. Особое внимание уделяется техническим решениям, которые позволили обеспечить работу виджета на платформах, не имеющих встроенной поддержки виджетов рабочего стола.

## От монолита к микросервисной архитектуре

### Исходная архитектура: монолитное приложение WinForms

Первая версия TimetableWidget представляла собой классическое Windows Forms приложение, написанное на C#. Вся функциональность была сосредоточена в единой кодовой базе объёмом около 1410 строк кода. Архитектура выглядела следующим образом:

```
Form1.cs (171 строка) — главное окно виджета с прозрачным оверлеем
├── TTApiManager.cs (189 строк) — бизнес-логика и API-вызовы
├── TokenStore.cs (61 строка) — локальное управление токенами
├── Settings.cs (68 строк) — сохранение настроек
├── Form2.cs (70 строк) — диалог авторизации
└── Form3.cs (65 строк) — диалог настроек
```

Приложение напрямую взаимодействовало с API университета, самостоятельно управляло аутентификацией, хранило токены и настройки локально в JSON-файлах. Для реализации функции перетаскивания виджета использовались прямые вызовы Windows API. Такой подход был прост в реализации и отлично работал на Windows, но имел существенные недостатки:

**Проблемы монолитного подхода:**

1. **Платформенная зависимость** — приложение работало только на Windows, перенос на Linux требовал полной переписки.

2. **Дублирование логики** — для каждой новой платформы пришлось бы заново реализовывать всю бизнес-логику (аутентификация, кэширование, работа с API).

3. **Сложность тестирования** — бизнес-логика была тесно связана с UI, что затрудняло модульное тестирование.

4. **Невозможность переиспользования кода** — вся логика была замешана с WinForms-специфичным кодом.

5. **Ограниченная масштабируемость** — добавление новых функций требовало изменения монолитной кодовой базы.

### Новая архитектура: бэкенд + адаптеры

Решением этих проблем стала радикальная перестройка архитектуры проекта. Вся бизнес-логика была вынесена в отдельный бэкенд на базе ASP.NET Core, который предоставляет REST API для любых клиентских приложений. Такой подход позволил создать тонкие клиентские адаптеры для различных платформ, которые отвечают только за отображение данных и взаимодействие с пользователем.

Новая архитектура выглядит следующим образом:

```
Backend (ASP.NET Core) — порт 5678
├── Controllers — HTTP endpoints
│   ├── AuthController — /api/auth/*
│   ├── TimetableController — /api/timetable/*
│   └── SettingsController — /api/settings/*
├── Services — бизнес-логика
│   ├── TimetableService — работа с API ЧувГУ, кэширование
│   ├── TokenStoreService — безопасное хранение токенов
│   └── SettingsService — управление настройками
└── Models — модели данных

Frontend Adapters (клиентские адаптеры)
├── WinForms — оригинальное приложение (в процессе миграции)
├── Cinnamon Desklet — JavaScript/GJS
├── KDE Plasma Widget — QML/JavaScript
├── GNOME Shell Extension — JavaScript/GJS
└── Python GTK — универсальное приложение-компаньон
```

**Преимущества новой архитектуры:**

1. **Слабая связанность** — фронтенд и бэкенд связаны только через HTTP API, что позволяет разрабатывать их независимо.

2. **Максимальное переиспользование кода** — вся бизнес-логика находится в бэкенде, фронтенды только отображают данные.

3. **Кроссплатформенность** — бэкенд написан на .NET Core, который работает как на Windows, так и на Linux.

4. **Простота расширения** — для поддержки новой платформы достаточно написать тонкий адаптер, вся логика уже есть в бэкенде.

5. **Удобство тестирования** — API можно тестировать независимо от UI.

6. **Централизованное управление** — обновление логики в бэкенде автоматически улучшает все фронтенды.

История Git-репозитория ясно показывает эволюцию проекта:
- `fd8d8cd` — начальный коммит с монолитным WinForms
- `c2201b6` — создание кроссплатформенного бэкенда
- Последовательное добавление адаптеров для Cinnamon, KDE, GNOME
- `2b65036` — добавление универсального Python GTK приложения

## Архитектура бэкенда

Бэкенд TimetableWidget построен на ASP.NET Core 10.0 и представляет собой веб-сервис, работающий локально на порту 5678. Основная задача бэкенда — предоставить унифицированный API для всех клиентских приложений, взяв на себя всю сложность работы с внешним API университета, управление сессиями и кэширование данных.

### REST API endpoints

Бэкенд предоставляет три группы endpoints:

**1. Аутентификация (/api/auth/)**
- `POST /api/auth/login` — авторизация пользователя по email и паролю
- `POST /api/auth/logout` — выход из системы
- `GET /api/auth/status` — проверка статуса аутентификации

**2. Расписание (/api/timetable/)**
- `GET /api/timetable/today` — получение расписания на сегодня
- `GET /api/timetable/tomorrow` — получение расписания на завтра

**3. Настройки (/api/settings/)**
- `GET /api/settings` — получение пользовательских настроек
- `PUT /api/settings` — обновление настроек
- `POST /api/settings/reset-position` — сброс позиции виджета

### Сервисный слой

Вся бизнес-логика инкапсулирована в трёх ключевых сервисах:

**TimetableService** — центральный сервис, который:
- Выполняет аутентификацию с API ЧувГУ (https://online.chuvsu.ru/api/v2)
- Управляет сессиями пользователей через токены
- Получает расписание занятий
- Реализует интеллектуальное кэширование с раздельными кэшами для сегодняшнего и завтрашнего расписания
- Фильтрует пары по подгруппам в соответствии с настройками пользователя
- Автоматически переключается на завтрашнее расписание, когда все занятия сегодня закончились
- Отслеживает состояние системы: "Loading", "Logged", "Not logged", "Nominal", "Error", "Wrong credentials"

**TokenStoreService** — обеспечивает безопасное хранение токенов:
- Использует ASP.NET Core Data Protection API для шифрования
- На Windows использует DPAPI для аппаратного шифрования
- На Linux использует файловое шифрование
- Токены хранятся в платформо-зависимых директориях:
  - Windows: `%LOCALAPPDATA%\TimetableWidget\`
  - Linux: `~/.local/share/TimetableWidget/`

**SettingsService** — управление настройками пользователя:
- Сохраняет настройки в JSON-файлах
- Кэширует настройки в памяти для быстрого доступа
- Управляет: позицией виджета (X, Y), ID сессии, номером подгруппы, прозрачностью, флагами отладки
- Предоставляет настройки по умолчанию при первом запуске

### Система кэширования

Одна из важных оптимизаций бэкенда — это 5-минутное кэширование запросов расписания. Кэширование реализовано отдельно для сегодняшнего и завтрашнего дня, что позволяет избежать излишних обращений к серверу университета и значительно ускоряет отклик приложения. Кэш автоматически инвалидируется при новой авторизации, чтобы гарантировать актуальность данных.

### CORS и кроссплатформенность

Для поддержки фронтендов на JavaScript (Cinnamon Desklet, GNOME Extension, KDE Plasma) в бэкенде настроена политика CORS "AllowAll", позволяющая запросы с любых источников на localhost. Это необходимо, так как некоторые адаптеры делают XHR-запросы из контекста графической оболочки.

## Адаптеры для различных платформ

Ключевая идея новой архитектуры — создание тонких адаптеров для каждой целевой платформы. Каждый адаптер использует нативные инструменты и API своего окружения для максимально естественной интеграции.

### Windows Forms (оригинальный адаптер)

Исходное монолитное приложение находится в процессе адаптации для работы с новым бэкендом. В текущем состоянии оно содержит всю бизнес-логику локально и напрямую обращается к API университета. После завершения миграции оно станет ещё одним тонким клиентом бэкенда.

**Технические особенности:**
- Технология: C# Windows Forms
- Прозрачное окно-оверлей поверх рабочего стола
- Использование Windows API для drag-and-drop функциональности
- Локальное хранение настроек в JSON
- Модальные диалоги для авторизации и настроек

### Cinnamon Desklet

Адаптер для окружения Cinnamon Desktop (Linux Mint) в виде нативного десклета.

**Технические особенности:**
- Технология: JavaScript (GJS) + GTK
- Встроенная интеграция с системой настроек Cinnamon
- GTK модальный диалог для аутентификации
- Управление: левый клик для обновления/входа, правый клик для меню
- Настройка прозрачности через панель настроек Cinnamon
- Автоматическое обновление по таймеру
- Основной код в файле `desklet.js` (~150 строк)

Cinnamon предоставляет богатый API для создания десклетов, что позволило создать полноценный виджет с минимальным количеством кода.

### KDE Plasma Widget

Плазмоид для экосистемы KDE Plasma — самого настраиваемого окружения Linux.

**Технические особенности:**
- Технология: QML (Qt Quick) + JavaScript
- Модульная архитектура с отдельным файлом `api.js` (59 строк) для работы с бэкендом
- QML-диалоги для авторизации (`LoginDialog.qml`) и настроек (`ConfigGeneral.qml`)
- Поддержка двух режимов: виджет на панели и виджет на рабочем столе
- Интеграция с системой конфигурации KDE
- Использование XMLHttpRequest для HTTP-запросов к бэкенду

QML позволяет создавать выразительный и производительный UI с декларативным синтаксисом, что делает код плазмоида читаемым и компактным.

### GNOME Shell Extension

Расширение для GNOME Shell — окружения по умолчанию в Ubuntu, Fedora и других популярных дистрибутивах.

**Технические особенности:**
- Технология: JavaScript (GJS) + GNOME Shell API
- Индикатор на панели с всплывающим меню
- Использование GSettings для хранения настроек
- XML-схема настроек: `org.gnome.shell.extensions.chuvsu-timetable.gschema.xml`
- Модальный диалог для аутентификации
- Интеграция с PopupMenu API
- CSS-стилизация через `stylesheet.css`
- Основной код в `extension.js` (~150 строк)

GNOME Shell накладывает строгие требования на расширения, но взамен предоставляет мощные возможности интеграции с оболочкой.

### Python GTK — универсальное приложение-компаньон

Самый универсальный адаптер, работающий на всех графических оболочках Linux без исключения.

**Технические особенности:**
- Технология: Python 3.7+ с GTK3 и PyGObject
- Модульная архитектура:
  - `window.py` — UI окна (~150 строк)
  - `api_client.py` — клиент для бэкенда (96 строк)
  - `config.py` — управление конфигурацией (109 строк)
- Безрамочное окно (frameless window) с поддержкой перетаскивания
- Настройки в `~/.config/timetable-widget/config.json`
- Автоматическая установка через скрипт `install.sh`
- Поддержка автозапуска при входе в систему
- Обновление каждые 5 секунд
- Поддерживаемые окружения: XFCE, MATE, LXQt, LXDE, Cinnamon, KDE Plasma, GNOME, Budgie, Pantheon

Python GTK является наиболее важным адаптером, так как решает проблему поддержки виджетов на окружениях, не имеющих собственного API для виджетов рабочего стола.

## Проблема поддержки виджетов и решение через GTK

### Различия в поддержке виджетов между окружениями

Разные графические оболочки Linux имеют кардинально разные подходы к виджетам рабочего стола:

**Окружения с нативной поддержкой виджетов:**
- **KDE Plasma** — имеет богатый API для Plasmoids, виджеты являются гражданами первого класса
- **Cinnamon** — поддерживает Desklets как отдельный тип приложений
- **GNOME** — поддерживает Extensions, но концепция виджетов на рабочем столе идёт вразрез с философией GNOME 3+

**Окружения без встроенной поддержки виджетов:**
- **XFCE** — лёгкое окружение без API для виджетов
- **MATE** — традиционное окружение с панелями, но без виджетов
- **LXQt/LXDE** — минималистичные окружения
- **Budgie** — современное окружение без концепции виджетов
- **i3/Sway** — тайловые менеджеры окон

Таким образом, для большинства популярных окружений необходимо было найти универсальное решение, которое не зависело бы от специфичного API конкретной оболочки.

### Концепция приложения-компаньона

Решением стало создание standalone-приложения на GTK3, которое эмулирует поведение виджета рабочего стола:

1. **Безрамочное окно** (`set_decorated(False)`) — окно без заголовка и кнопок управления
2. **Позиционирование под другими окнами** (`set_keep_below(True)`) — виджет всегда остаётся на заднем плане
3. **Тип окна DOCK** (`set_type_hint(Gdk.WindowTypeHint.DOCK)`) — система воспринимает окно как док-панель
4. **Скрытие из панели задач** (`set_skip_taskbar_hint(True)`) — виджет не отображается в списке окон
5. **Поддержка прозрачности** — использование RGBA визуала для альфа-канала

Благодаря этим настройкам, обычное GTK-окно ведёт себя как нативный виджет рабочего стола.

### Архитектура Python GTK приложения

**Жизненный цикл приложения:**

1. **Запуск:**
   - Загрузка конфигурации из `~/.config/timetable-widget/config.json`
   - Восстановление позиции окна (X, Y координаты)
   - Установка размера и прозрачности
   - Инициализация API-клиента с URL бэкенда

2. **Проверка аутентификации (таймаут 100мс):**
   - Запрос `GET /api/auth/status` к бэкенду
   - Если аутентифицирован → запуск таймера автообновления
   - Если нет → повторная проверка каждые 10 секунд

3. **Цикл автообновления (интервал 5 секунд):**
   - Запрос `GET /api/timetable/today` или `tomorrow`
   - Парсинг расписания (дисциплины, время, аудитории)
   - Обновление UI с новыми данными
   - Бэкенд управляет кэшем (5 минут)

4. **Drag & Drop:**
   - `button-press-event` — начало перетаскивания
   - `motion-notify-event` — перемещение окна за курсором
   - `button-release-event` — сохранение новой позиции в конфигурацию

5. **Завершение:**
   - Сохранение финальной позиции в config
   - Закрытие HTTP-сессии
   - Корректный выход без необходимости явного logout

**Система конфигурации:**

Приложение использует JSON-файл для хранения всех настроек:

```json
{
  "backend_url": "http://localhost:5678",
  "x": 100,
  "y": 100,
  "width": 400,
  "height": 500,
  "group": 0,
  "transparency": 0.95,
  "update_interval": 300,
  "auto_start": false
}
```

Класс `Config` предоставляет удобный property-based доступ к настройкам и автоматически сохраняет изменения в файл.

**Автоматическая установка:**

Скрипт `install.sh` автоматизирует весь процесс установки:
- Установка зависимостей Python через системный пакетный менеджер или venv
- Копирование приложения в `/usr/local/lib/timetable-widget/`
- Создание launcher-скрипта в `/usr/local/bin/timetable-widget`
- Создание .desktop файла в `~/.local/share/applications/`
- Настройка автозапуска через `~/.config/autostart/`

Скрипт обрабатывает проблемы с окончаниями строк (dos2unix) и корректно работает на всех основных дистрибутивах Linux.

## Сравнительный анализ адаптеров

Каждый адаптер имеет свои сильные и слабые стороны, обусловленные особенностями целевой платформы:

| Характеристика | WinForms | Cinnamon | KDE Plasma | GNOME | Python GTK |
|----------------|----------|----------|------------|-------|------------|
| **Технология** | C# | JavaScript/GJS | QML | JavaScript | Python |
| **Платформа** | Windows | Linux | Linux | Linux | Linux (все) |
| **Нативность** | Высокая | Высокая | Высокая | Средняя | Средняя |
| **Простота установки** | Exe-файл | Drag&Drop | Drag&Drop | Установка через Extensions | Скрипт install.sh |
| **Интеграция с DE** | N/A | Отличная | Отличная | Хорошая | Универсальная |
| **Объём кода** | ~1400 строк | ~150 строк | ~200 строк | ~150 строк | ~350 строк |
| **Зависимости** | .NET Framework | GJS, GTK | Qt5, KDE Frameworks | GNOME Shell | Python3, GTK3, PyGObject |
| **Настройки** | Локальный JSON | Cinnamon Settings | KDE Config | GSettings | Локальный JSON |

**Вывод:**
- Для пользователей KDE, Cinnamon и GNOME предпочтительны нативные адаптеры, обеспечивающие глубокую интеграцию с окружением
- Для всех остальных окружений (XFCE, MATE, LXQt и др.) оптимальным выбором является Python GTK
- Windows Forms адаптер остаётся единственным вариантом для пользователей Windows

## Технические паттерны и лучшие практики

### Разделение ответственности (Separation of Concerns)

Ключевой принцип новой архитектуры — чёткое разделение обязанностей:
- **Бэкенд** отвечает за бизнес-логику, аутентификацию, кэширование, работу с внешними API
- **Фронтенды** отвечают только за отображение данных и взаимодействие с пользователем
- Никакой бизнес-логики в адаптерах, только UI-код

### Стратегия кэширования

Двухуровневое кэширование обеспечивает оптимальный баланс между актуальностью данных и нагрузкой на сервер:
- **Уровень 1:** Раздельные кэши для today/tomorrow (5 минут каждый)
- **Уровень 2:** Инвалидация при новой авторизации
- Результат: минимизация запросов к серверу ЧувГУ при гарантии актуальности

### Кроссплатформенная защита данных

ASP.NET Core Data Protection API обеспечивает прозрачное шифрование токенов:
- На Windows используется DPAPI с привязкой к учётной записи пользователя
- На Linux используется файловое шифрование с ключами в защищённых директориях
- Клиентский код не знает о деталях реализации — просто вызывает `GetToken()`/`SetToken()`

### Управление состоянием

Бэкенд отслеживает детальное состояние системы:
- **"Loading"** — инициализация
- **"Not logged"** — требуется авторизация
- **"Logged"** — авторизация выполнена
- **"Nominal"** — нормальная работа
- **"Error"** — системная ошибка
- **"Wrong credentials"** — неверные учётные данные

Фронтенды регулярно опрашивают состояние и адаптируют UI соответственно.

### Автоматизация развёртывания

Проект включает скрипты автозапуска для бэкенда и фронтендов:
- Бэкенд может запускаться как системный сервис или при входе пользователя
- Python GTK автоматически добавляется в автозагрузку через .desktop файлы
- Скрипты обрабатывают различия между дистрибутивами (systemd, init.d, autostart)

## Заключение

Эволюция TimetableWidget от монолитного Windows Forms приложения к современной микросервисной архитектуре демонстрирует классический паттерн развития программного обеспечения. Переход к архитектуре "бэкенд + адаптеры" потребовал значительных усилий, но принёс множество преимуществ:

**Достижения:**
1. **Кроссплатформенность** — поддержка Windows и всех основных окружений Linux
2. **Модульность** — бизнес-логика отделена от UI, что упрощает тестирование и поддержку
3. **Масштабируемость** — добавление новых платформ требует только написания тонкого адаптера
4. **Производительность** — централизованное кэширование снижает нагрузку на внешние сервисы
5. **Безопасность** — платформо-независимое шифрование токенов

**Решение проблемы виджетов:**
Создание универсального приложения-компаньона на Python GTK решило проблему отсутствия поддержки виджетов на многих популярных окружениях. Используя низкоуровневые возможности GTK (frameless windows, window hints, transparency), удалось эмулировать поведение нативного виджета без зависимости от специфичных API конкретных оболочек.

**Техническая архитектура:**
Использование ASP.NET Core для бэкенда, REST API для коммуникации и нативных технологий для адаптеров (QML для KDE, GJS для GNOME/Cinnamon, Python для универсального решения) обеспечивает оптимальный баланс между производительностью, нативностью и простотой разработки.

**Будущее проекта:**
Следующим шагом является завершение миграции оригинального Windows Forms адаптера на новый API бэкенда, что позволит унифицировать архитектуру всех клиентских приложений. Модульная структура проекта позволяет легко добавлять поддержку новых платформ — потенциальными кандидатами являются macOS (с использованием Swift/AppKit) и веб-версия (Progressive Web App).

Опыт разработки TimetableWidget показывает, что правильная архитектура — это не та, которая решает все проблемы сразу, а та, которая позволяет эволюционировать вместе с требованиями и технологиями. Переход от монолита к микросервисам открыл проекту новые горизонты и превратил локальное Windows-приложение в действительно кроссплатформенное решение.
